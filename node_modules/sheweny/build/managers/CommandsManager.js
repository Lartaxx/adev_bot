"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CommandsManager = void 0;
const collection_data_1 = require("collection-data");
const events_1 = require("events");
const loadFiles_1 = require("../utils/loadFiles");
/**
 * Manager for Commands
 * @extends {EventEmitter}
 */
class CommandsManager extends events_1.EventEmitter {
    /**
     * Constructor to manage commands
     * @param {ShewenyClient} client Client framework
     * @param {string} directory Directory of the commands folder
     * @param {CommandsManagerOptions} [options] Options of the commands manager
     */
    constructor(client, directory, options) {
        super();
        if (!client)
            throw new TypeError("Client must be provided.");
        if (!directory)
            throw new TypeError("Directory must be provided.");
        this.client = client;
        this.directory = directory;
        this.guildId = options?.guildId;
        this.prefix = options?.prefix;
        this.applicationPermissions = options?.applicationPermissions || false;
        if (options?.loadAll)
            this.loadAndRegisterAll();
        client.handlers.commands = this;
    }
    /**
     * Load all commands in collection
     * @returns {Promise<Collection<string, Command>>}
     */
    async loadAll() {
        const commands = await (0, loadFiles_1.loadFiles)(this.client, this.directory, "name");
        this.client.collections.commands = commands;
        this.commands = commands;
        return commands;
    }
    /**
     * Load all and Register Application commands
     * @returns {Promise<void>}
     */
    async loadAndRegisterAll() {
        const commands = await this.loadAll();
        await this.registerAllApplicationCommands(commands);
    }
    /**
     * Rename command type to the type of Application command
     * @param {"SLASH_COMMAND" | "CONTEXT_MENU_USER" | "CONTEXT_MENU_MESSAGE"} type Type of command
     * @returns {ApplicationCommandType | undefined}
     */
    renameCommandType(type) {
        if (type === "SLASH_COMMAND")
            return "CHAT_INPUT";
        if (type === "CONTEXT_MENU_MESSAGE")
            return "MESSAGE";
        if (type === "CONTEXT_MENU_USER")
            return "USER";
        return undefined;
    }
    /**
     * Get data of Application Command
     * @param {Collection<string, Command> | Command | undefined} [commands] The command(s) to obtain their data
     * @returns {ApplicationCommandData[] | ApplicationCommandData | undefined}
     */
    getData(commands = this.commands) {
        if (!commands)
            throw new Error("Commands not found");
        if (commands instanceof collection_data_1.Collection) {
            const data = [];
            for (let [, cmd] of commands) {
                if (cmd.type === "MESSAGE_COMMAND")
                    continue;
                const newType = this.renameCommandType(cmd.type);
                if (!newType)
                    continue;
                if (cmd.type === "SLASH_COMMAND") {
                    data.push({
                        type: newType,
                        name: cmd.name,
                        description: cmd.description,
                        options: cmd.options,
                        defaultPermission: this.applicationPermissions &&
                            this.guildId &&
                            cmd.userPermissions.length > 0
                            ? false
                            : cmd.defaultPermission,
                    });
                }
                else if (cmd.type === "CONTEXT_MENU_MESSAGE" ||
                    cmd.type === "CONTEXT_MENU_USER") {
                    data.push({
                        type: newType,
                        name: cmd.name,
                        defaultPermission: this.applicationPermissions &&
                            this.guildId &&
                            cmd.userPermissions.length > 0
                            ? false
                            : cmd.defaultPermission,
                    });
                }
            }
            return data;
        }
        else {
            if (commands.type === "MESSAGE_COMMAND")
                return undefined;
            const newType = this.renameCommandType(commands.type);
            if (!newType)
                return undefined;
            if (commands.type === "SLASH_COMMAND") {
                return {
                    type: newType,
                    name: commands.name,
                    description: commands.description,
                    options: commands.options,
                    defaultPermission: this.applicationPermissions &&
                        this.guildId &&
                        commands.userPermissions.length > 0
                        ? false
                        : commands.defaultPermission,
                };
            }
            else if (commands.type === "CONTEXT_MENU_MESSAGE" ||
                commands.type === "CONTEXT_MENU_USER") {
                return {
                    type: newType,
                    name: commands.name,
                    defaultPermission: this.applicationPermissions &&
                        this.guildId &&
                        commands.userPermissions.length > 0
                        ? false
                        : commands.defaultPermission,
                };
            }
        }
    }
    /**
     * Set all application commands from the collection of commands in the client application
     * @param {Collection<string, Command> | undefined} [commands] Collection of the commands
     * @returns {Promise<CollectionDjs<Snowflake, ApplicationCommand<{}>> | CollectionDjs<Snowflake, ApplicationCommand<{ guild: GuildResolvable }>> | undefined>}
     */
    async registerAllApplicationCommands(commands = this.commands, guildId = this.guildId) {
        if (!commands)
            throw new Error("Commands not found");
        const data = this.getData();
        await this.client.awaitReady();
        if (data instanceof Array && data.length > 0) {
            const cmds = guildId
                ? await this.client.application?.commands.set(data, guildId)
                : await this.client.application?.commands.set(data);
            if (this.applicationPermissions)
                await this.registerPermissions(cmds);
            return cmds;
        }
        return undefined;
    }
    /**
     * Set permissions for each commands in guild
     * @param {CollectionDjs<string, ApplicationCommand<{}>> | undefined} [applicationCommands] Commands coming from the client's application
     * @param {Collection<string, Command> | undefined} [commandsCollection] Commands coming from the collection of the commands
     * @param {Snowflake | undefined} [guildId] Guild ID where permissions will be set
     * @returns {Promise<void>}
     */
    async registerPermissions(applicationCommands = this
        .client.application?.commands.cache, commandsCollection = this.commands, guildId = this.guildId) {
        if (!applicationCommands)
            throw new ReferenceError("Commands of application must be provided");
        if (!commandsCollection)
            throw new ReferenceError("Commands of client must be provided");
        if (!guildId)
            throw new ReferenceError("Guild ID must be provided");
        if (guildId instanceof Array)
            return guildId.every(async (gId) => await this.registerPermissions(applicationCommands, commandsCollection, gId));
        const guild = this.client.guilds.cache.get(guildId);
        const getRoles = (command) => {
            if (command.userPermissions?.length === 0)
                return null;
            return guild?.roles.cache.filter((r) => r.permissions.has(command.userPermissions));
        };
        const fullPermissions = [];
        for (const [, appCommand] of applicationCommands) {
            const roles = getRoles(commandsCollection.get(appCommand.name));
            const permissions = [];
            if (roles && roles.size)
                for (const [, role] of roles) {
                    permissions.push({ id: role.id, type: "ROLE", permission: true });
                }
            if (this.client.admins && this.client.admins.length)
                for (const userId of this.client.admins) {
                    permissions.push({ id: userId, type: "USER", permission: true });
                }
            fullPermissions.push({
                id: appCommand.id,
                permissions,
            });
        }
        await guild?.commands.permissions.set({ fullPermissions });
    }
    /**
     * Create a command in the client's application commands
     * @param {Command} command Command to create
     * @param {Snowflake | undefined} [guildId] Guild ID where the order will be created
     * @returns {Promise<ApplicationCommand<{}> | ApplicationCommand<{ guild: GuildResolvable }> | undefined>}
     */
    async createCommand(command, guildId) {
        if (!command)
            throw new Error("Command not found");
        const data = this.getData(command);
        if (!data)
            return undefined;
        return guildId
            ? this.client.application?.commands.create(data, guildId)
            : this.client.application?.commands.create(data);
    }
    /**
     * Edit an command with a new command in the client's application commands
     * @param {ApplicationCommandResolvable} oldCommand Command edited
     * @param {Command} newCommand The new command that will take the place of the old one
     * @param {Snowflake | undefined} [guildId] Guild ID where the order will be edited
     * @returns {Promise<ApplicationCommand<{}> | ApplicationCommand<{ guild: GuildResolvable }> | undefined>}
     */
    async editCommand(oldCommand, newCommand, guildId) {
        if (!oldCommand)
            throw new Error("Old Command not found");
        if (!newCommand)
            throw new Error("New Command not found");
        const data = this.getData(newCommand);
        if (!data)
            return undefined;
        return guildId
            ? this.client.application?.commands.edit(oldCommand, data, guildId)
            : this.client.application?.commands.edit(oldCommand, data);
    }
    /**
     * Removes an command from the client's application commands
     * @param {ApplicationCommandResolvable} command Command deleted
     * @param {Snowflake | undefined} [guildId] Guild ID where the command will be deleted
     * @returns {Promise<ApplicationCommand<{ guild: GuildResolvable }> | null | undefined>}
     */
    async deleteCommand(command, guildId) {
        if (!command)
            throw new Error("Command not found");
        return guildId
            ? this.client.application?.commands.delete(command, guildId)
            : this.client.application?.commands.delete(command);
    }
    /**
     * Delete all commands from the client's application commands
     * @param {Snowflake | undefined} [guildId] Guild ID where all commands will be deleted
     * @returns {Promise<CollectionDjs<string, ApplicationCommand<{}>> | CollectionDjs<string, ApplicationCommand<{ guild: GuildResolvable }>> | undefined>}
     */
    async deleteAllCommands(guildId) {
        return guildId
            ? this.client.application?.commands.set([], guildId)
            : this.client.application?.commands.set([]);
    }
}
exports.CommandsManager = CommandsManager;
